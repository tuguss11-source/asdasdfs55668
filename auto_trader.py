# auto_trader.py - YENƒ∞ DOSYA
import time
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import sqlite3
import requests
import hmac
import hashlib
import urllib.parse

# Logging setup
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AutoTrader:
    def __init__(self, config=None):
        self.config = config or {
            "paper_trading": True,
            "max_positions": 5,
            "daily_loss_limit": -0.1,  # -%10
            "min_signal_strength": 7,
            "max_position_size": 0.1,  # %10 portf√∂y
            "default_leverage": "3x"
        }
        
        # Trading durumu
        self.is_running = False
        self.active_positions = []
        self.trade_history = []
        self.daily_pnl = 0
        
        # Exchange baƒülantƒ±larƒ±
        self.exchanges = {}
        self.init_exchanges()
        
        # Risk y√∂neticisi
        self.risk_manager = None
        
        logger.info("ü§ñ Auto Trader Ba≈ülatƒ±ldƒ±")
    
    def init_exchanges(self):
        """Exchange baƒülantƒ±larƒ±nƒ± ba≈ülat"""
        try:
            # Binance entegrasyonu
            self.exchanges['binance'] = BinanceExchange()
            logger.info("‚úÖ Binance exchange baƒülantƒ±sƒ± hazƒ±r")
        except Exception as e:
            logger.error(f"‚ùå Exchange baƒülantƒ± hatasƒ±: {e}")
    
    def execute_trade(self, signal_data: Dict) -> Dict:
        """Trade y√ºr√ºt - ana fonksiyon"""
        try:
            symbol = signal_data.get('symbol', '')
            signal_type = signal_data.get('signal', {}).get('sinyal', 'BEKLE')
            
            if signal_type == 'BEKLE':
                return {"status": "skipped", "reason": "BEKLE sinyali"}
            
            # Risk kontrol√º
            risk_check = self.check_trade_risk(signal_data)
            if not risk_check.get('approved', False):
                return {"status": "rejected", "reason": risk_check.get('reason', 'Risk limiti')}
            
            # Paper trading mi ger√ßek trading mi?
            if self.config['paper_trading']:
                return self.execute_paper_trade(signal_data)
            else:
                return self.execute_real_trade(signal_data)
                
        except Exception as e:
            logger.error(f"‚ùå Trade execution hatasƒ±: {e}")
            return {"status": "error", "reason": str(e)}
    
    def execute_paper_trade(self, signal_data: Dict) -> Dict:
        """Paper trade y√ºr√ºt"""
        try:
            symbol = signal_data.get('symbol', '')
            signal = signal_data.get('signal', {})
            signal_type = signal.get('sinyal', 'BEKLE')
            
            # Paper trade detaylarƒ±
            trade_details = {
                'trade_id': f"paper_{int(time.time())}",
                'symbol': symbol,
                'action': signal_type,
                'entry_price': signal.get('giris_fiyati', 0),
                'quantity': signal.get('pozisyon_buyuklugu', 0),
                'timestamp': datetime.now().isoformat(),
                'status': 'filled',
                'paper_trading': True,
                'risk_amount': signal.get('risk_miktari', 0),
                'leverage': signal.get('kaldƒ±ra√ß', '1x')
            }
            
            # Paper position'a ekle
            self.active_positions.append(trade_details)
            
            logger.info(f"üìù Paper Trade: {symbol} {signal_type} - ${trade_details['entry_price']:,.2f}")
            
            return {
                "status": "success",
                "trade_id": trade_details['trade_id'],
                "paper_trading": True,
                "details": trade_details
            }
            
        except Exception as e:
            logger.error(f"‚ùå Paper trade hatasƒ±: {e}")
            return {"status": "error", "reason": str(e)}
    
    def execute_real_trade(self, signal_data: Dict) -> Dict:
        """Ger√ßek trade y√ºr√ºt"""
        try:
            symbol = signal_data.get('symbol', '')
            signal = signal_data.get('signal', {})
            signal_type = signal.get('sinyal', 'BEKLE')
            
            # Exchange'e g√∂re sembol formatƒ±nƒ± d√ºzenle
            exchange_symbol = self.format_symbol_for_exchange(symbol, 'binance')
            
            # Order parametreleri
            order_params = {
                'symbol': exchange_symbol,
                'side': 'BUY' if signal_type == 'AL' else 'SELL',
                'quantity': signal.get('pozisyon_buyuklugu', 0),
                'price': signal.get('giris_fiyati', 0),
                'leverage': signal.get('kaldƒ±ra√ß', '1x')
            }
            
            # Binance'e order g√∂nder
            exchange = self.exchanges.get('binance')
            if exchange:
                order_result = exchange.place_order(order_params)
                
                if order_result.get('status') == 'FILLED':
                    # Trade history'e ekle
                    trade_record = {
                        'trade_id': order_result.get('orderId', ''),
                        'symbol': symbol,
                        'action': signal_type,
                        'entry_price': order_result.get('price', 0),
                        'quantity': order_result.get('executedQty', 0),
                        'timestamp': datetime.now().isoformat(),
                        'status': 'filled',
                        'paper_trading': False,
                        'exchange': 'binance'
                    }
                    
                    self.trade_history.append(trade_record)
                    self.active_positions.append(trade_record)
                    
                    logger.info(f"üéØ Real Trade: {symbol} {signal_type} - ${order_result.get('price', 0):,.2f}")
                    
                    return {
                        "status": "success",
                        "trade_id": trade_record['trade_id'],
                        "paper_trading": False,
                        "exchange": "binance",
                        "details": trade_record
                    }
                else:
                    return {
                        "status": "exchange_error",
                        "reason": order_result.get('msg', 'Exchange hatasƒ±')
                    }
            else:
                return {"status": "error", "reason": "Exchange baƒülantƒ±sƒ± yok"}
                
        except Exception as e:
            logger.error(f"‚ùå Real trade hatasƒ±: {e}")
            return {"status": "error", "reason": str(e)}
    
    def check_trade_risk(self, signal_data: Dict) -> Dict:
        """Trade risk kontrol√º"""
        try:
            symbol = signal_data.get('symbol', '')
            signal = signal_data.get('signal', {})
            
            # 1. Sinyal g√ºc√º kontrol√º
            signal_strength = signal.get('g√º√ß', 0)
            if signal_strength < self.config['min_signal_strength']:
                return {"approved": False, "reason": "Sinyal g√ºc√º yetersiz"}
            
            # 2. Pozisyon sayƒ±sƒ± kontrol√º
            if len(self.active_positions) >= self.config['max_positions']:
                return {"approved": False, "reason": "Maksimum pozisyon sayƒ±sƒ± a≈üƒ±ldƒ±"}
            
            # 3. G√ºnl√ºk kayƒ±p limiti kontrol√º
            if self.daily_pnl <= self.config['daily_loss_limit']:
                return {"approved": False, "reason": "G√ºnl√ºk kayƒ±p limiti a≈üƒ±ldƒ±"}
            
            # 4. Aynƒ± sembolde a√ßƒ±k pozisyon kontrol√º
            existing_position = any(pos['symbol'] == symbol for pos in self.active_positions)
            if existing_position:
                return {"approved": False, "reason": "Aynƒ± sembolde a√ßƒ±k pozisyon var"}
            
            # 5. Position size kontrol√º
            position_size = signal.get('pozisyon_buyuklugu', 0)
            position_value = position_size * signal.get('mevcut_fiyat', 0)
            if position_value > self.config['max_position_size']:
                return {"approved": False, "reason": "Pozisyon b√ºy√ºkl√ºƒü√º limiti a≈üƒ±ldƒ±"}
            
            return {"approved": True, "reason": "Risk kontrol√º ba≈üarƒ±lƒ±"}
            
        except Exception as e:
            logger.error(f"‚ùå Risk kontrol hatasƒ±: {e}")
            return {"approved": False, "reason": "Risk kontrol hatasƒ±"}
    
    def format_symbol_for_exchange(self, symbol: str, exchange: str) -> str:
        """Sembol formatƒ±nƒ± exchange'e g√∂re d√ºzenle"""
        if exchange == 'binance':
            # BINANCE:BTCUSDT -> BTCUSDT
            return symbol.replace('BINANCE:', '')
        return symbol
    
    def close_position(self, symbol: str, reason: str = "manual") -> Dict:
        """Pozisyonu kapat"""
        try:
            # Aktif pozisyonu bul
            position = next((pos for pos in self.active_positions if pos['symbol'] == symbol), None)
            
            if not position:
                return {"status": "error", "reason": "Pozisyon bulunamadƒ±"}
            
            # Paper trading ise
            if position.get('paper_trading', True):
                # Sim√ºle exit price (entry price ¬± %2)
                import random
                price_change = random.uniform(-0.02, 0.02)
                exit_price = position['entry_price'] * (1 + price_change)
                
                # P&L hesapla
                pnl = (exit_price - position['entry_price']) * position['quantity']
                if position['action'] == 'SAT':
                    pnl = -pnl  # Short pozisyon i√ßin tersi
                
                self.daily_pnl += pnl
                
                # Pozisyonu kapat
                self.active_positions.remove(position)
                
                # Trade history'i g√ºncelle
                position['exit_price'] = exit_price
                position['pnl'] = pnl
                position['exit_reason'] = reason
                position['exit_timestamp'] = datetime.now().isoformat()
                
                logger.info(f"üìù Paper Position Closed: {symbol} - P&L: ${pnl:,.2f}")
                
                return {
                    "status": "success",
                    "pnl": pnl,
                    "exit_price": exit_price,
                    "paper_trading": True
                }
            else:
                # Ger√ßek pozisyon kapatma
                exchange = self.exchanges.get('binance')
                if exchange:
                    # Tersi y√∂nde order olu≈ütur
                    close_side = 'SELL' if position['action'] == 'AL' else 'BUY'
                    close_result = exchange.place_order({
                        'symbol': self.format_symbol_for_exchange(symbol, 'binance'),
                        'side': close_side,
                        'quantity': position['quantity'],
                        'price': 0,  # Market price
                        'type': 'MARKET'
                    })
                    
                    if close_result.get('status') == 'FILLED':
                        # P&L hesapla
                        exit_price = close_result.get('price', 0)
                        pnl = (exit_price - position['entry_price']) * position['quantity']
                        if position['action'] == 'SAT':
                            pnl = -pnl
                        
                        self.daily_pnl += pnl
                        self.active_positions.remove(position)
                        
                        logger.info(f"üéØ Real Position Closed: {symbol} - P&L: ${pnl:,.2f}")
                        
                        return {
                            "status": "success",
                            "pnl": pnl,
                            "exit_price": exit_price,
                            "paper_trading": False
                        }
                    else:
                        return {"status": "error", "reason": "Exchange kapatma hatasƒ±"}
                else:
                    return {"status": "error", "reason": "Exchange baƒülantƒ±sƒ± yok"}
                    
        except Exception as e:
            logger.error(f"‚ùå Position close hatasƒ±: {e}")
            return {"status": "error", "reason": str(e)}
    
    def get_portfolio_status(self) -> Dict:
        """Portf√∂y durumunu getir"""
        total_value = 0
        total_pnl = 0
        
        for position in self.active_positions:
            current_value = position['quantity'] * position.get('current_price', position['entry_price'])
            total_value += current_value
            
            position_pnl = (position.get('current_price', position['entry_price']) - position['entry_price']) * position['quantity']
            if position['action'] == 'SAT':
                position_pnl = -position_pnl
            total_pnl += position_pnl
        
        return {
            'active_positions': len(self.active_positions),
            'total_value': total_value,
            'total_pnl': total_pnl,
            'daily_pnl': self.daily_pnl,
            'max_positions': self.config['max_positions']
        }
    
    def reset_daily_pnl(self):
        """G√ºnl√ºk P&L'ƒ± sƒ±fƒ±rla (gece yarƒ±sƒ± √ßaƒürƒ±lmalƒ±)"""
        self.daily_pnl = 0
        logger.info("üîÑ G√ºnl√ºk P&L sƒ±fƒ±rlandƒ±")

class BinanceExchange:
    """Binance exchange entegrasyonu"""
    
    def __init__(self, api_key="", api_secret="", testnet=True):
        self.base_url = "https://testnet.binance.vision" if testnet else "https://api.binance.com"
        self.api_key = api_key
        self.api_secret = api_secret
        self.session = requests.Session()
        
        if api_key:
            self.session.headers.update({'X-MBX-APIKEY': api_key})
    
    def place_order(self, order_params: Dict) -> Dict:
        """Order yerle≈ütir"""
        try:
            # Testnet i√ßin sim√ºle response
            if not self.api_key:
                return self._simulate_order(order_params)
            
            # Ger√ßek Binance API call
            endpoint = "/api/v3/order"
            params = {
                'symbol': order_params['symbol'],
                'side': order_params['side'],
                'type': 'LIMIT',
                'quantity': order_params['quantity'],
                'price': order_params['price'],
                'timeInForce': 'GTC'
            }
            
            # Signature ekle
            params['timestamp'] = int(time.time() * 1000)
            params['signature'] = self._generate_signature(params)
            
            response = self.session.post(self.base_url + endpoint, params=params)
            
            if response.status_code == 200:
                return response.json()
            else:
                return {"status": "error", "msg": response.text}
                
        except Exception as e:
            logger.error(f"‚ùå Binance order hatasƒ±: {e}")
            return {"status": "error", "msg": str(e)}
    
    def _simulate_order(self, order_params: Dict) -> Dict:
        """Test i√ßin sim√ºle order"""
        time.sleep(0.5)  # Sim√ºle latency
        
        return {
            "orderId": int(time.time()),
            "symbol": order_params['symbol'],
            "status": "FILLED",
            "clientOrderId": f"sim_{int(time.time())}",
            "price": order_params['price'],
            "origQty": str(order_params['quantity']),
            "executedQty": str(order_params['quantity']),
            "cummulativeQuoteQty": str(float(order_params['price']) * float(order_params['quantity'])),
            "type": "LIMIT",
            "side": order_params['side'],
            "transactTime": int(time.time() * 1000)
        }
    
    def _generate_signature(self, params: Dict) -> str:
        """API signature olu≈ütur"""
        query_string = urllib.parse.urlencode(params)
        return hmac.new(
            self.api_secret.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    def get_account_info(self) -> Dict:
        """Hesap bilgilerini getir"""
        try:
            endpoint = "/api/v3/account"
            params = {'timestamp': int(time.time() * 1000)}
            params['signature'] = self._generate_signature(params)
            
            response = self.session.get(self.base_url + endpoint, params=params)
            
            if response.status_code == 200:
                return response.json()
            else:
                return {"error": response.text}
        except Exception as e:
            return {"error": str(e)}

# Trade Manager Factory
class TradeManagerFactory:
    @staticmethod
    def create_trader(trader_type="auto", config=None):
        if trader_type == "auto":
            return AutoTrader(config)
        else:
            return AutoTrader(config)  # Fallback